---
description: This rule governs the implementation of mixed ordered (ol) and unordered (ul) lists in web editors. It should be applied when: (1) Building or maintaining rich text editors with list functionality, (2) Implementing indentation controls for nested lists, (3) Debugging issues with list type preservation during indentation changes, (4) Styling nested list structures, or (5) Implementing tab key behavior for list manipulation. This rule ensures proper HTML structure, consistent styling, and correct behavior when mixing list types, especially when manipulating list depth with tab/shift+tab.
globs: 
alwaysApply: false
---
--- 
bullet listì˜ ê¸°ëŠ¥ì€ ë‹¤ìŒê³¼ ê°™ì•„ 
ì—ë””í„°ì˜ ì»¨í…ì¸  ì˜ì—­ì—ì„œ ë¸”ë¡ì„ ì„ íƒí•œ ë’¤ bullet listë¥¼ í´ë¦­í•˜ë©´ ì•„ë˜ì™€ ê°™ì´ depthì— ë”°ë¼ bulletì´ ì ìš©ë˜ì–´ì•¼ í•´ 
depthëŠ” ê³„ì† ë” ê¹Šì–´ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ css í•˜ë“œ ì½”ë”©ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ì—†ì–´.
â€¢	1 depth: â— (disc)
â€¢	2 depth: â—‹ (circle)
â€¢	3 depth: â–  (square)
â€¢	4 depth ì´í›„ë¶€í„°ëŠ” ë‹¤ì‹œ â—, â—‹, â–  ìˆœìœ¼ë¡œ ë°˜ë³µ

depth ëŠ” ì„ íƒí•œ ì»¤ì„œ ìœ„ì¹˜ì—ì„œ tabí‚¤ë¡œ indent ë˜ì–´ì•¼ í•´ 

rule ì§€ì¹¨ì„ ì˜ ë”°ë¼ì„œ ì‘ì„±í•´ì£¼ê³  @plugin-util.js ì— ê³µí†µ ìš”ì†Œë“¤ì„ ì ìš©í•´ì„œ ê°„ê²°í•˜ê²Œ ê¸°ëŠ¥ ì½”ë“œë¥¼ ì‘ì„±í•´ì¤˜ 
--- 
# Mixed Ordered and Unordered List Implementation

## Critical Rules

- Always properly nest list items by placing child lists (`ul` or `ol`) inside parent `li` elements, never directly inside another list
- Maintain correct list type during indentation changes by preserving the original list type when increasing/decreasing depth
- Explicitly set `list-style-type` in CSS for both `ul` and `ol` elements to prevent unintentional style inheritance
- Implement tab key handlers that check the parent list type before changing indentation to preserve list types
- Use CSS reset for list margins and consistent padding to ensure proper visual nesting
- Include proper left padding on nested lists (typically 1.5em) to create visual hierarchy
- Set `list-style-type: inherit` for deeply nested lists only when intentionally cascading styles
- When implementing JavaScript list manipulation, always check current list type before changing indentation
- Apply different list markers for different nesting levels to enhance visual hierarchy (disc â†’ circle â†’ square for `ul`)
- Ensure keyboard accessibility by implementing proper tab/shift+tab behavior for list manipulation

Step 1: Implement bullet list application to selection area
Apply bullet list only to current selection area
Save selection area before execution and find corresponding UL element after execution
Implement clear UL element identification logic
Step 2: Implement depth-based style application logic
Function to accurately calculate actual nesting depth of UL elements
Apply style (1â†’disc(â—), 2â†’circle(â—‹), 3â†’square(â– )) according to depth
Apply style only to direct target UL
Step 3: Implement indent/outdent via Tab/Shift+Tab key
Add Tab key event handler
Implement direct DOM manipulation method to maintain standard HTML structure
Indent: Move current LI to the lower level of previous LI
Outdent: Move current LI to a higher level
Step 4: HTML standard structure verification and normalization
Detect and fix structures that do not conform to HTML standards
Ensure UL is always nested inside LI
Implement automatic normalization function for non-standard structures
Step 5: Debugging and stabilization
Add sufficient logging to all steps
Error handling and exception handling
Test various scenarios


## Examples

<example>
// Proper HTML nesting structure
<ul>
  <li>Bullet item 1
    <ol>
      <li>Numbered sub-item 1.1</li>
      <li>Numbered sub-item 1.2</li>
    </ol>
  </li>
  <li>Bullet item 2</li>
</ul>

// Proper CSS styling
ul, ol {
  margin: 0;
  padding-left: 1.5em;
}

ul {
  list-style-type: disc;
}

ol {
  list-style-type: decimal;
}

ul li ul,
ol li ol {
  margin: 0;
  padding-left: 1.5em;
}

// JavaScript tab key handler
function handleTabKey(event) {
  if (event.key === 'Tab') {
    event.preventDefault();
    const currentItem = getSelectedListItem();
    const parentList = currentItem.parentElement.parentElement;
    
    if (event.shiftKey) {
      // Outdent - preserve list type when moving outward
      decreaseDepth(currentItem, parentList.nodeName.toLowerCase());
    } else {
      // Indent - preserve current list type when moving inward
      increaseDepth(currentItem, parentList.nodeName.toLowerCase());
    }
  }
}
</example>

<example type="invalid">
// Incorrect HTML nesting (lists not inside li)
<ul>
  <li>Bullet item 1</li>
  <ol>
    <li>This is incorrect nesting</li>
  </ol>
  <li>Bullet item 2</li>
</ul>

// Missing explicit styles allows unintended inheritance
ul, ol {
  margin: 0;
  padding-left: 1.5em;
}
// Missing list-style-type declarations

// Incorrect tab handling that changes list types
function handleTabKey(event) {
  if (event.key === 'Tab') {
    event.preventDefault();
    const currentItem = getSelectedListItem();
    
    // Incorrect: Always creates ul regardless of parent type
    if (!event.shiftKey) {
      createNestedList('ul', currentItem);
    }
  }
}
</example>

/**
 * LiteEditor Bullet List Plugin
 * - ë¶ˆë¦¿ ë¦¬ìŠ¤íŠ¸ ì„œì‹ê³¼ ê¹Šì´ë³„ ìŠ¤íƒ€ì¼ ì ìš© (ì„ íƒí•œ ë¦¬ìŠ¤íŠ¸ë§Œ ì ìš©)
 * - ê·œì¹™: 011-numberlist-bulletlist-rule-agent.mdc
 */
(function() {
  // í”ŒëŸ¬ê·¸ì¸ ë“±ë¡
  PluginUtil.registerPlugin('unorderedList', {
    title: 'Bullet List',
    icon: 'format_list_bulleted',
    action: function(contentArea, buttonElement, event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      
      // 1. ì‹¤í–‰ ì „ ì„ íƒ ì˜ì—­ ì •ë³´ ì €ì¥
      const selection = window.getSelection();
      const savedRange = selection.rangeCount > 0 ? selection.getRangeAt(0).cloneRange() : null;
      
      // ì‹¤í–‰ ì „ ì¡´ì¬í•˜ëŠ” UL ìš”ì†Œë“¤ ìŠ¤ëƒ…ìƒ· ì €ì¥ (ë¹„êµë¥¼ ìœ„í•´)
      const ulsBefore = Array.from(contentArea.querySelectorAll('ul'));
      
      // ì—ë””í„° ì˜ì—­ì— í¬ì»¤ìŠ¤
      contentArea.focus();
      
      // 2. ë¶ˆë¦¿ ëª©ë¡ ìƒì„±/ì‚­ì œ ëª…ë ¹ ì‹¤í–‰
      document.execCommand('insertUnorderedList', false, null);
      
      // 3. ëª…ë ¹ ì‹¤í–‰ í›„ ì„ íƒëœ ì˜ì—­ì˜ UL ì°¾ê¸°
      setTimeout(() => {
        const targetUl = findTargetUl(contentArea, savedRange, ulsBefore);
        
        if (targetUl) {
          console.log('âœ… íƒ€ê²Ÿ UL ì°¾ìŒ:', targetUl);
          // ë‹¤ìŒ ë‹¨ê³„: ì—¬ê¸°ì„œ ìŠ¤íƒ€ì¼ ì ìš© í•¨ìˆ˜ í˜¸ì¶œ ì˜ˆì •
          // (2ë‹¨ê³„ì—ì„œ êµ¬í˜„í•  í•¨ìˆ˜)
        } else {
          console.warn('âŒ íƒ€ê²Ÿ ULì„ ì°¾ì„ ìˆ˜ ì—†ìŒ');
        }
      }, 10);
    }
  });
  
  /**
   * ì„ íƒí•œ ì˜ì—­ì— í•´ë‹¹í•˜ëŠ” UL ìš”ì†Œë¥¼ ì°¾ëŠ” í•¨ìˆ˜
   * @param {HTMLElement} contentArea - ì—ë””í„° ì˜ì—­
   * @param {Range} savedRange - ì €ì¥ëœ ì„ íƒ ì˜ì—­
   * @param {Array} ulsBefore - ëª…ë ¹ ì‹¤í–‰ ì „ ì¡´ì¬í•˜ë˜ UL ìš”ì†Œë“¤
   * @return {HTMLElement|null} ì°¾ì€ UL ìš”ì†Œ ë˜ëŠ” null
   */
  function findTargetUl(contentArea, savedRange, ulsBefore) {
    // 1. ìƒˆë¡œ ìƒì„±ëœ UL ì°¾ê¸° (ê°€ì¥ ì •í™•í•œ ë°©ë²•)
    const ulsAfter = Array.from(contentArea.querySelectorAll('ul'));
    const newUls = ulsAfter.filter(ul => !ulsBefore.includes(ul));
    
    if (newUls.length > 0) {
      console.log('ğŸ” ìƒˆë¡œ ìƒì„±ëœ UL ë°œê²¬');
      return newUls[0];
    }
    
    // 2. ì„ íƒ ì˜ì—­ ì£¼ë³€ì—ì„œ UL ì°¾ê¸° (ìƒˆ ULì´ ì—†ëŠ” ê²½ìš°)
    if (savedRange) {
      const container = savedRange.commonAncestorContainer;
      
      // ì»¨í…Œì´ë„ˆê°€ ì§ì ‘ ULì¸ ê²½ìš°
      if (container.nodeName === 'UL') {
        console.log('ğŸ” ì„ íƒ ì˜ì—­ì´ ì§ì ‘ UL');
        return container;
      }
      
      // ë¶€ëª¨ ì¤‘ UL ì°¾ê¸°
      let parent = container;
      while (parent && parent !== contentArea) {
        if (parent.nodeName === 'UL') {
          console.log('ğŸ” ë¶€ëª¨ì—ì„œ UL ë°œê²¬');
          return parent;
        }
        if (parent.nodeName === 'LI' && parent.parentNode && parent.parentNode.nodeName === 'UL') {
          console.log('ğŸ” ë¶€ëª¨ LIì˜ ìƒìœ„ì—ì„œ UL ë°œê²¬');
          return parent.parentNode;
        }
        parent = parent.parentNode;
      }
      
      // ìì‹ ì¤‘ UL ì°¾ê¸° (ë¶€ëª¨ì—ì„œ ëª» ì°¾ì€ ê²½ìš°)
      if (container.nodeType === Node.ELEMENT_NODE) {
        const childUl = container.querySelector('ul');
        if (childUl) {
          console.log('ğŸ” ìì‹ì—ì„œ UL ë°œê²¬');
          return childUl;
        }
      }
    }
    
    // 3. í˜„ì¬ ì„ íƒ ì˜ì—­ ê¸°ì¤€ìœ¼ë¡œ ì¬í™•ì¸
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      
      if (container.nodeName === 'UL') {
        console.log('ğŸ” í˜„ì¬ ì„ íƒ ì˜ì—­ì´ UL');
        return container;
      }
      
      let parent = container;
      while (parent && parent !== contentArea) {
        if (parent.nodeName === 'UL') {
          console.log('ğŸ” í˜„ì¬ ë¶€ëª¨ì—ì„œ UL ë°œê²¬');
          return parent;
        }
        if (parent.nodeName === 'LI' && parent.parentNode && parent.parentNode.nodeName === 'UL') {
          console.log('ğŸ” í˜„ì¬ ë¶€ëª¨ LIì˜ ìƒìœ„ì—ì„œ UL ë°œê²¬');
          return parent.parentNode;
        }
        parent = parent.parentNode;
      }
    }
    
    // í˜„ì¬ ì„ íƒëœ í…ìŠ¤íŠ¸ ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œì˜ ê°€ì¥ ê°€ê¹Œìš´ UL ì°¾ê¸°
    try {
      const currentNode = window.getSelection().getRangeAt(0).startContainer;
      const closestLi = currentNode.nodeType === Node.TEXT_NODE ? 
                        currentNode.parentNode.closest('li') : 
                        currentNode.closest('li');
      
      if (closestLi) {
        const parentUl = closestLi.closest('ul');
        if (parentUl) {
          console.log('ğŸ” í˜„ì¬ í…ìŠ¤íŠ¸ ë…¸ë“œ ì£¼ë³€ì—ì„œ UL ë°œê²¬');
          return parentUl;
        }
      }
    } catch (e) {
      console.warn('ì„ íƒ ì˜ì—­ ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', e);
    }
    
    return null; // ì°¾ì§€ ëª»í•œ ê²½ìš°
  }
})();
